
/** \page tutorial_first_process First VNX process
 * 
 * In this tutorial we create a simple process that's using VNX to write a value to a file.
 * 
 * We will write a vnx::Marker instance which is a so called "value" because it inherits from vnx::Value.
 * 
 * The Marker class is defined in a VNI file (Marker.vni) as follows: 
 * \code{.java}
package vnx;

class Marker {
	long time;
	string message;
}
 * \endcode
 * 
 * Based on the VNI (ie. Virtual Network Interface) definition a Marker.hxx and a Marker.cpp has been generated by \p vnxcppcodegen.
 * Since Marker is included in VNX we do not have to do the code generation step right now.
 * 
 * Here is the code:
 * 
 * \include doc/tutorials/first_process.cpp
 * 
 * The code can be compiled with:
 * \code
 * g++ -o first_process first_process.cpp -std=c++11 -lvnx_base
 * \endcode
 * 
 * Running the program will produce a "test.dat" file containing the type information (the so called "type code", ie. a vnx::TypeCode)
 * as well as the value (ie. a vnx::Marker, which is a vnx::Value):
 * \code
 * $ ls -l test.dat
 * -rw-r--r-- 1 mad mad 187 Okt 18 04:29 test.dat
 * \endcode
 * 
 * We can see the file is 187 bytes, most of which is the type code, the actual value is only 8 + (4 + "Hello World!") = 24 bytes.
 * The type code however is only written once to a stream, be it a file or a TCP/UNIX socket.
 * 
 * Using \p vnxread we can see what's in the file:
 * 
 * \code
$ vnxread -f test.dat
{
  "time": 1539829760479134,
  "message": "Hello World!"
}
 * \endcode
 * 
 * Because the type information is contained in the file \p vnxread doesn't need any additional information to print the contents as a JSON object.
 * 
 */
